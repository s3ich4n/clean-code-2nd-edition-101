# Clean Code Study - Week3
#### 2023-07-23. Sun. written by HT.LEE
<h2> Ch8. Boundaries </h2>
<h3> 소개 </h3>
이번 챕터에서는 주로 Third-Party code(=외부 패키지나 라이브러리 등)를 사용했을 때, 일어날 수 있는 문제에 대해 다룬다. Third-Party code를 사용하면 종종 '나의 코드(=내부코드)'와 '남의 코드(=외부코드)' 사이의 경계(Boundaries)가 발생한다. 이러한 경계에 대해 주의 깊게 다루지 않는다면 코드가 클린하지 못하게 될 수도 있다.   

이번 챕터에서 배울 내용   
1. 내부 코드와 외부 코드 사이의 경계가 문제가 되는 근원
2. 외부 코드의 변화에 유연한 코드를 작성하는 방법
3. 학습 테스트(learning test)의 개념, 예시
4. 학습 테스트의 가치와 의의
5. Known과 Unknown 사이에서의 경계
6. 깨끗한 경계의 철학   

<h3> Using Third-Party Code </h3>

* 인터페이스 제공자와 사용자 사이에는 필연적인 긴장(tension)이 있다
    + 제공자 : 다양한 환경과 최대한 넓은 층의 고객들에게 어필할 수 있는 보편적 기능성을 제공하고 싶어 한다.
    + 사용자 : 그들 자신의 특수한 목적에 필요한 요구를 충족시키길 바란다.

    + 예시 - 매우 범용적으로 사용하는 java.util.Map을 사용할 때조차 일어날 수 있는 골칫거리

    ex_1) 
    ```Java
    Map sensors = new HashMap();
    Sensor s = (Sensor)sensors.get(sensorId);
    ```
    클라이언트 코드에서 HashMap인스턴스인 sensors의 특정 id로 Sensor 하나 접근할 때마다 Object를 정확한 타입으로 type-casting 일일이 해줘야 한다.

    ex_2) 제네릭으로 타입을 지정해주는 방법
    ```Java
    Map<Sensor> sensors = new HashMap<Sensor>();
    Sensor s = sensors.get(sensorId);
    ```
    시스템에서 외부 코드(여기서는 Map<Sensor>)의 인스턴스가 경솔하게 여기저기 전달된다는 것은 외부 인터페이스가 변경될 경우 수정할 곳도 많아진다는 것을 의미한다.

    Map<sensor>와 같은 java.util.Map은 괜찮을 것이다고 생각할 수도 있지만, 이것 역시 Java5에서도 변경되었다는 점을 기억하라.

    ex_3) Wrapper를 사용하는 방법
    ```Java
    public class Sensors{
        private Map sensors = new HashMap();
        
        public Sensor getById(String id){
            return (Sensor)sensors.get(id);
        }
        //snip
    }
    ```
    ex_2보다 더 나은 방법이다.
    사용자 쪽에서 외부 인터페이스에 대한 노출을 최소화하는 방법으로, 이렇게 하면 경계에 있는 인터페이스(여기서는 Map)가 은닉된다. (The interface at the boundary is hidden). 외부 인터페이스가 변경되었을 때 내부 코드가 충격받을 부분이 줄어든다.

    <b> Easy to understand and harder to misuse!</b>
    
    - 경계 인터페이스를 사용한다면, 그것이 사용되는 클래스 내부에 두거나, 클래스들의 가까운 부류의 내부에 둬라. 
    - public API 쓸 때, 경계에 있는 인스턴스를 직접적으로 반환하는 것을 피하라.
    - public API 쓸 때, 경계에 있는 인스턴스를 인자로 넣는 것을 피하라.

<h3> Exploring and Learning Boundaries </h3>
Third-Party Code 자체를 테스팅하는 건 우리의 일이 아닐 것이지만, 우리가 사용하는 Third-Party Code의 어떤 모듈의 동작 방식을 테스트하고 이해하는 것은 충분히 할 필요성이 있다.

지금 우리가 직접 사용하려는 Third-Party Code를 제대로된 이해 없이 사용하다간, 나중에 우리의 코드와 외부 코드가 뒤엉켜서 어디에서 버그가 났는지를 고치느라 시간을 허비할 것이다.

따라서 이해와 올바른 사용을 위해  "학습 테스트"를 하는 것은 <b>매우 실용적</b>이다.

학습테스트에서는, 우리는 우리의 응용에서 사용하길 기대하는 Third-Party API를 호출한다. 그리고 해당 API의 이해를 점검하기 위해 통제된 실험을 한다.

<h3> Learning log4j </h3>
  이 부분은 Apache log4j 패키지를 이해하기 위해 학습테스트를 사용한 예시에 대한 절이다.
  방법론적 내용이므로 책을 참고하길 바란다.

<h3> Learning Tests Are Better Than Free (학습테스트는 공짜 이상이다) </h3>
결론 : 학습테스트는 가성비 최고의 도구이다.

- 비용이 안 든다.
- 쉽고 고립된 방식으로 외부 코드가 어떻게 동작되는 지를 내 방식으로 이해할 수 있다.
- 외부 코드가 변화했을 때, (변화하기 전의) 학습테스트를 돌려봄으로써, 동작의 차이, 호환의 문제 등이 있는지 확인할 수 있다.
- 코드를 통합한 이후에는 코드가 우리의 기대되로 돌아갈 것이라는 보장이 없는데, 학습테스트를 돌려봄으로써 이러한 위험을 예방할 수 있다.
- 테스트를 통해 경계 문제를 명확하게 지원할 수 있어야 한다. 마이그레이션을 쉽게 하기 위한 이러한 경계테스트가 없으면 오래된 버전의 외부 API를 계속 유지하고 방치하고자 하는 게으름에 빠지기 쉽다.

<h3> Using Code That Does Not Yet Exist </h3>
경계의 또다른 유형으로 아는 것과 모르는 것을 구분하는 경계가 있다. 가끔씩 도메인에 대한 지식이 부족하거나 여타 다른 이유로 세부 구현 동작에 대해 아직은 정의할 수 없는 영역(Unknown)이 있다. 그러나, 엄연히 Unknown 인터페이스 역시 다른 클래스 및 인터페이스와 상호작용을 하기 때문에 아예 없는 것처럼 취급할 수는 없다.

이런 경우, <b>구현과 인터페이스를 분리</b>하는 것이 가장 좋은 방법이다. 공통적으로 사용되는 인터페이스로 빼고, 실제 구현은 나중에 Unknown에 대해 "알게 될 때까지" 미뤄둘 수 있다. Adapter pattern이나 Mock 객체를 사용하는 것이 이러한 상황에서 좋은 해결책이 될 수 있다.

<h3> Clean Boundaries </h3>
경계 문제를 고려한 설계는 Third-Party code가 변경되었을 때, 비용과 재작업을 최소화 할 수 있다. 경계에 있는 코드는 (경계 내외에 대한) 분명한 분리와 기대를 충족하는 테스팅이 반드시 필요하다. 네가 제어하지 못하는 것에 의존하는 것보다 네가 제어할 수 있는 것에 의존하는 것이 훨씬 낫다. 통제의 주도권을 항상 당신이 가지도록 하라.

- - -
+ 심화 학습
    - Mocking에 대해 알아볼 것!
    - Adapter Pattern 예시 짜볼 것!
    - See more about seams in [WELC].
